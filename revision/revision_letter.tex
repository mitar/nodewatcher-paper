\documentclass[12pt,twoside,a4paper]{report}

\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage[margin=0.7in]{geometry}
\usepackage[normalem]{ulem}
\usepackage[sc]{mathpazo}
\usepackage[T1]{fontenc}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{mathtools}

\usepackage{multirow}
\usepackage{ctable}
\usepackage{colortbl}
\usepackage{subfig}
\usepackage{dcolumn}
\usepackage{url}


\newcommand{\myspace}{5cm}

\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{listings}
\usepackage{url}

% ADDED
\usepackage{ctable}
\usepackage{subfig}
\usepackage{array}
\usepackage{multirow}
\usepackage{colortbl}
\usepackage[shortcuts]{extdash}

% nested calls
\renewcommand*\Call[2]{\textproc{#1}(#2)}

% NEW COMMANDS
\newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{R}[1]{>{\raggedleft\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}

% Function names
\DeclareMathOperator{\Trust}{Trust}
\DeclareMathOperator{\Aggregate}{Aggregate}
\DeclareMathOperator{\Median}{Median}
\DeclareMathOperator{\mor}{mor}
\DeclareMathOperator{\MOR}{MOR}
\DeclareMathOperator{\Rank}{\textsc{Rank}}
\DeclareMathOperator*{\argmin}{\arg\!\min}

% elements
\newcommand{\D}{\mathit{D}}
\newcommand{\PD}{\mathit{PD}}
\newcommand{\I}{\mathit{I}}
\newcommand{\PT}{\mathit{PT}}
\newcommand{\T}{\mathit{T}}

% algs
\floatname{algorithm}{Listing}
\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}
\newcommand{\pushcode}[1][1]{\hskip\dimexpr#1\algorithmicindent\relax} % for condition over two lines

\newcommand{\nodewatcher}{\textit{nodewatcher}}
\newcommand{\wlanslovenija}{\textit{wlan slovenija}}

\frenchspacing
\begin{document}%\maketitle
\pagestyle{empty}
\begin{center} {\Large{Authors' response to the review of the paper COMNET-D-15-148}}\\
    ``\emph{\nodewatcher{}: A Substrate for Growing Your own Community Network}''\\
    submitted to Computer Networks
\end{center}

\noindent We would like to thank the Editor and the reviewers for their comments. We have found them to be very constructive and they have helped us greatly to improve the manuscript. On the subsequent pages we provide detailed responses to the reviewers' comments and we indicate the modifications that we made in the text. The following list represents the major changes.
\begin{itemize}
\item Added Figure 1 to better motivate the difference between proprietary and community networks.
\item Updated Section 3.1 and updated Figure 2 to show the overview of the role that the proposed system has in a community network.
\item Added Table 1 that provides a quantitative overview of related work.
\item Reorganized Section 3 to follow the steps in the device management cycle.
\item Added Section 3.3.2, to better describe how the platform deals with hardware diversity.
\item Updated the discussion section to include a subsection on security, availability and implementing federation support.
\end{itemize}

\noindent In addition to these major changes (which are in detail explained in the subsequent pages as responses to concrete comments from the reviewers), we have also made several minor changes (corrected spelling mistakes, shortened some paragraphs, ...) that we do not highlight in this revision letter.

\noindent When providing responses (and marking corresponding changes in the manuscript), we denote existing references with numbers in square brackets, for instance [1], while we denote newly added references in full by inlining them.\\
\\
\noindent Sincerely,\\
Jernej Kos, Mitar Milutinović and Luka Čehovin

\newpage

\section*{Response to Reviewer \#1}

\vspace{0.5cm}\noindent\textsc{General}\\
\noindent The paper presents  the design choices of nodewatcher, a community network management system. The design is valuable. The idea of starting from a platform independent configuration and then of producing a device dependent firmware to easy the configuration, monitoring and maintenance procedures sounds very good. Also to include the monitoring in the platform itself to validate presumed configurations with actual ones is a nice idea.
Overall the "work" is valuable and it is extremely relevant with the call for paper.

\vspace{0.5cm}\noindent\textsc{Comment 1}\\
However the paper is a little bit boring. The authors have difficulty in simply explaining at higher level the system architecture and get the discussion in too much details, in order to motivate any choice. It would be better to introduce an overview section with highlights all the user/administrator steps from the user decision to participate to the community network up to the time when her node is operational. By sequentially of describing each piece of the (good) system, the reader have a complete view only at the end. And this discourage the reading. In would be better to provide a bird-eye-view at the start of the paper. 

\vspace{0.2cm}\noindent\textsc{Response}\\
In the revised version we have updated the entire Section 3 to better motivate our choices and to make the structure of the paper more clear. Starting with the overview in Section 3.1, we have updated the description with a more user-centric scenario that ties in the rest of the text in this section through the device management cycle.
The Figure 2 (was Figure 1 in the previous revision) has also been updated to better show the role of the community in the process of network creation and maintenance. Furthermore the rest of the Section 3 has been restructured to follow the description in the overview. In particular we have:

\begin{itemize}
\item Updated Section 3.2 (\textit{Platform-independent configuration}) that describes the modules that are important in the configuration step.
In this section we have merged Section 3.2.1 (\textit{Form generation and rule-based defaults}, former Section 3.3) and Section 3.2.2 (\textit{Resource allocation}, former Section 3.4).
\item Updated Section 3.3 (\textit{Firmware generator}) that describes the modules that are important in the generation step.
This section has been restructured into Section 3.3.1 (\textit{Transforming configuration}) and Section 3.3.2 (\textit{Supporting hardware diversity}).
\item Updated Section 3.4 (\textit{Network monitoring}) that describes the modules that are important in the monitoring step.
This section has been restructured into Section 3.4.1 (\textit{Obtaining telemetry data}), Section 3.4.2 (\textit{Monitoring pipelines}) and Section 3.4.3 (\textit{Storing monitored data}, former Section 3.7).
\end{itemize}

In addition to this we have also modified the introduction a bit and added Figure 1 to better motivate the difference between proprietary and community networks. The description of the proposed system is indeed long, however, we would like to emphasize that an in-depth motivation of the main parts is necessary in an interdisciplinary project that combines elements from computer networking, database systems, operating systems, web-based user interfaces, and large-scale data aggregation and visualization. We believe that the modifications to the manuscript provide a clearer and more consistent description of the proposed system, as requested by the reviewer. 

\newpage

\section*{Response to Reviewer \#2}

\vspace{0.5cm}\noindent\textsc{General}\\
The authors present the v3 of "nodewatcher" a new community network management platform built around the core principle of modularity and extensibility and discuss its implementation in wlan slovenija, a CN in Slovenia, and claim to be a general solution for CNs. The paper is well written and the authors show a wide theoretical and practical knowledge on the topic. The design of nodewatcer v3 takes into account the learning from its previous versions as well as from the results of the analysis of other CNs management platforms. Nodewatcher integrates the "device manage cycle" to automate the configuration and monitoring tasks, which is a good idea but which implementation raises doubts due to the inherent challenges and the expected assumptions required to put into practice. The modular design of the data base is a good solution to the limitations of the implementations of other CNs.

The platform uses up to date technologies (json, etc.), is well documented (although there are still some "TODO" sections) and includes nice features such as a real-life demo or a Docker development environment. Although the work presented is a good contribution towards the noble and (utopian?) "CN-independent" solution objective, in this author opinion, despite the authors claim, the solution is still tight to some of the developers' CN traits.

\vspace{0.5cm}\noindent\textsc{Comment 1}\\
Please discuss: 1) how nodewatcher with hardware diversity and novelty. Which are the constrains (e.g. OpenWRT like firmwares required? Implications of requirement of having to install a daemon in each node). Recommendations for new adopters and specially for (massive) migrations.

\vspace{0.5cm}\noindent\textsc{Response}\\
{\em Hardware diversity.} We have now added a subsection detailing how \nodewatcher{} is able to deal with hardware diversity and novelty.
The subsection now contains the following paragraphs.

\begin{quote}

[...]

Different community networks use various hardware devices.
Additionally, new hardware is being developed all the time.
Therefore in order for the platform to really be useful, it must make it really easy to support new devices and even whole new operating systems.
To enable this, \nodewatcher{} splits hardware support into different components, which may be provided by independent modules:

\begin{description}
    \item[Runtime platform.] The runtime platform is dependent upon the operating system that runs on the target device.
    OpenWrt and RouterOS are examples of runtime platforms.
    But there is no hardcoded concept of how a platform should behave.
    What defines the runtime platform are the transformation modules, which contain the logic of converting the platform-independent configuration into something that can be understood by the target device.

    \item[Firmware builders.] Separate from the runtime platform are the firmware builders.
    They contain toolchains, which are able to generate firmware images that may be copied directly onto the target device.
    In case the devices are using proprietary operating systems, these may not even exist.
    Decoupling the builders from the runtime platform means that proprietary runtime platforms can also be supported.
    In such cases, configuration will still need to be applied manually.

    \item[Hardware device descriptors.] These are the device descriptors that we have already defined.
    They provide to the transformation modules the knowledge required to correctly adapt the platform-dependent configuration to the target device.
    Since a device may in theory support different runtime platforms (eg. some Mikrotik devices may use either OpenWrt or RouterOS), the same device descriptor can be reused by multiple runtime platforms.
    In this case, the platform-specific properties are specified for each platform, while the common ones are specified only once for each device.
\end{description}

Firmware builders are kept separate from the runtime platform, so that proprietary systems may be supported.
The link between the runtime platform and the firmware builders is the platform-specific configuration.
This configuration is the output of the transformation modules defined for the target runtime platform.

The toolchains used to build firmware images for embedded devices can be complex and may vary wildly between the runtime platforms.
This is why the firmware build system in \nodewatcher{} has been designed in such a way that it can be used by completely different toolchains in a modular fashion.
To achieve this, the build system is structured into multiple Docker containers~[34].
Docker containers are a lightweight wrapper around the Linux namespacing API and filesystem layers with a goal to enable an interface for packaging applications in a reusable and extensible way.
Namespaces provide container isolation (the containers still share the host kernel), so that adjacent containers running on the same host are unable to see or influence each other's processes, network configuration, etc.
Each container can be thought of as a very lightweight virtual instance, but without the overhead of running a full virtual machine with its own kernel.
\nodewatcher{} uses the Docker container features in order to generate and run firmware image builders for multiple runtime platforms.

After the platform-specific configuration has been generated by the transformation step of the given runtime platform (see the node \textit{Device and OS Specific Config.} in Figure~6), a suitable builder is selected based on the hardware architecture specified in the device descriptor.
The \nodewatcher{} platform connects to the firmware builder containers using secure shell (SSH) connections.
After a connection is established, the platform-specific configuration is transferred and the build process is started.
When it finishes (for OpenWrt, this is a matter of seconds), the generated firmware images are transferred back so they can be made available to the user.
This decoupling of platform-specific configuration and firmware builders enables the builder containers to be distributed and deployed on a cluster of machines to better handle the load, resource availability and utilization.
The described system is also extensible~-- adding support for new architectures simply requires a new builder container to be prepared, while adding support for new runtime platforms also requires an extension of the configuration transformation pipeline.

[...]
\end{quote}

\noindent {\em Installation of a daemon on each node.} In Section~3.6 we describe how the agent runs on the node, collects data and enables the \nodewatcher{} backend to acquire the data from the ndoes.
But as we mention in the following paragraph, this notion of our own monitoring agent is just one possible way of handling reporting.
We have modified the paragraph to make this more clear.

\begin{quote}

[...]

The implemented agent that uses JSON over HTTP(S) connections is just one of the possible monitoring data source implementations.
The architecture enables other data collection protocols to be used side-by-side.
One possible such protocol, that many existing device operating systems already support, is SNMP.
While our custom protocol enables easier schema evolution through per-module versions, SNMP may be used in cases where custom monitoring agents cannot be installed on target devices.
This co-existence of data sources is enabled by the modular design of the monitoring backend.

[...]

\end{quote}

\vspace{0.5cm}\noindent\textsc{Comment 2}\\
Please clarify (and discuss the consequences if appropriated): 1) if all nodes need to see each other. I.e. how isolated clouds are handled, does each need a nodewatcher? if so, what if two nodes merge. Federation. if it splits?

\vspace{0.5cm}\noindent\textsc{Response}\\
Recently, \nodewatcher{} has gained support for nodes to push data in addition to the data being pulled from them. 
This now enables setups where the nodewatcher instance does not even have access to the mesh network, but is just placed somewhere on the public Internet.
We have modified the section describing the monitoring agent to contain this new development.

\begin{quote}

[...]

It is a small C application with a minimal core that is able to periodically request the loaded modules to provide their state updates which are then compiled into the current node status and exported in a JSON form.
There are then two ways for the agent to transfer the data to the nodewatcher backend:
\begin{itemize}
    \item \textbf{Pull.} The JSON data may be served over HTTP(S) and the nodewatcher monitoring backend will periodically request new data from the nodes.

    \item \textbf{Push.} The agent on the node will periodically push its monitoring data to the backend using HTTP(S) POST requests. This requires that the push URL and interval be configured on the node.
\end{itemize}

This behaviour of the agent may be configured per-node.
Some nodes may push data while data is pulled from others.
Supporting both modes of operation is beneficial for situations where the \nodewatcher{} backend installation does not directly see every node in the mesh network, but is instead located somewhere in the public Internet, without VPN access to the network itself.
With push support, nodes may provide telemetry data even in this case, by pushing data to a public URL.

[...]

\end{quote}

By isolated clouds, we assume that the reviewer means different sub-communities, for example in large community networks that need to segment things into multiple independent routing domains.
There is currently no explicit support for federation in \nodewatcher{}.
But it is still possible to implement federation, which we now discuss in a subsection, containing the following paragraphs.

\begin{quote}

[...]

Community networks are by their nature decentralized networks which grow in an ad-hoc fashion.
Some community networks may be concerned that having a centralized management system presents a single point of failure for the network, compromise its security or centralize the community too much.
In this section we analyse these concerns and argue that this may not be the case.

[...]

The issue of centralization can be addressed by federation. 
While \nodewatcher{} core does not explicitly support federated deployments, its modular nature enables communities to easily implement it as a module.
Assuming that there are multiple independent subcommunities within one larger community, there are two basic approaches in making \nodewatcher{} federated.

\begin{description}
    \item[Independent installations.] Each independent subcommunity or routing domain would have its own \nodewatcher{} installation which performs registration and monitoring for its own nodes.
    In this way, it would be completely independent from the centralized instance.
    If the community then wants to have an aggregated picture of the whole network, another top-level \nodewatcher{} instance may be deployed which will use pull and/or push from all the other subcommunity \nodewatcher{} installations.
    In this manner, the top-level installation would not support registration of nodes and would not monitor the nodes directly.
    Since in \nodewatcher{} these are all modules, they can be easily removed.
    Instead, the top-level instance would just get the data from subcommunity installations and use it as is.
    Because of the modular design, one would only need to develop a module that knows how to aggregate this data from multiple subcommunities and store it using the existing schema.

    \item[Single installation.] The problem with having multiple installations is that it may be hard to handle merge/split scenarios.
    So instead of having multiple installations, one could also use just a single \nodewatcher{} installation and just structure the nodes and permissions in such a way that each subcommunity has their space.
    This is similar to how the Guifi.net~[17, 24] dashboard splits nodes into zones.
    In this case, the server infrastructure would still be shared, but control would be distributed over multiple communities.
    Since there is no need for all the nodes to see each other (only \nodewatcher{} needs to be able to communicate with them), this is already possible using the current implementation.
    Currently, there is a module that supports \textit{projects}, but these have a completely flat structure.
    A flat structure does not scale to a large number of subcommunities.
    A better way would be to develop a module that would enable nicer visual grouping of nodes, using a parent-child concept similar to the Guifi.net zones.
    As far as topology and map visualizations go, the existing implementation already supports disconnected islands of nodes.
\end{description}

[...]

\end{quote}

\vspace{0.5cm}\noindent\textsc{Comment 3}\\
  2) if how to develop "monitor pipelines" presented Fig.6 is well documented, e.g. to develop one for BGP
  
\vspace{0.5cm}\noindent\textsc{Response}\\
It depends on the routing daemon that is in use.
There needs to be a way for \nodewatcher{} to connect to the routing daemon and obtain topology information and announced networks from it.
As far as we are aware, both Quagga and Bird expose such data via an IPC protocol (in case of Bird, there is even a Python interface for this protocol\footnote{\url{https://pypi.python.org/pypi/pybird}}).
Currently, \nodewatcher{} implements modules for two commonly used routing protocols, namely OLSR and Babel.
In a similar way, a module for monitoring BGP could be added.
But in addition to monitoring, this same module could also implement functionality to configure Bird or Quagga for use in the network, leveraging the same configuration architecture that is already used for generating firmwares.

\newpage

\section*{Response to Reviewer \#3}

\vspace{0.5cm}\noindent\textsc{General}\\
The paper briefly reviews existing traditional and specialized monitoring and management solutions for wireless community networks and then presents detailed design concepts and example use cases of the novel nodewatcher v3 platform that focuses on modularity and extensibility with the objective of being adapted by many communities and finally break the circle of letting each community reinvent the wheel and produce their own proprietary and incompatible solutions again and again.

The issue of network management represents an indeed major aspect of the daily and long-term life-cycle of community networks as well as their propagation and growth around the world and certainly deserves a (i) fundamental review of common practices, existing solutions, and open issues and (ii) the fundamental rethinking of tools and approaches.

\vspace{0.5cm}\noindent\textsc{Comment 1}\\
Particularly in the former aspect, the review given by the paper could be significantly enhanced. The paper covers in too great detail technical engineering decisions to achieve the somehow common objectives of modularity and extensibility, which are of course noble goals. But it reads a lot like a white paper or technical report that praises a bit too much its own achievements without providing sufficient quantitative or qualitative comparison or overview of existing solutions, weaknesses, unaddressed aspects or yet achieved disseminations and impacts.

A table summarizing characteristics of existing management solutions would be desirable, (e.g. showing features, addressed issues, concerns, openness, usage, age, developer community size, ...).

\vspace{0.5cm}\noindent\textsc{Response}\\
We have now performed a comprehensive survey of all existing community network management solutions that we could find.
The result is now visible in Table~1, quoting from the paper:

\begin{quote}

[...]

\newcommand{\push}{$\uparrow$}
\newcommand{\pull}{$\downarrow$}

\newcommand{\no}{$\times$}
\newcommand{\yes}{$\checkmark$}
\newcommand{\maybe}{$\circ$}

\newcommand{\static}{S}
\newcommand{\dynamic}{D}

Many wireless mesh network communities have quickly recognized the need for having a central system that would be able to manage the growing number of wireless mesh nodes.
We present a comprehensive overview of properties of existing solutions in Table~1. The data was obtained by studying the public information available about the projects (e.g. source code) and verified by reaching out to the members of the corresponding communities.
We list several properties of community network management solutions, starting with the name of the project and the community that forms its core development group.
We show whether the project is being actively developed and when was it first officially mentioned and deployed in an actual network.
Properties are then organized into three major areas, namely  features (functionality that the system has), modularity/extensibility (can the individual functionalities be extended without modifying the core) and developer accessibility.
For most of the features, we list whether the described system implements the feature fully (\yes), only partially (\maybe) or not at all (\no).
In case of network monitoring, we also list whether the system supports pulling data from nodes (\pull) and if nodes can push data to the system (\push).
For topology visualization, we mark whether the system renders the topology just based on configuration (\static) or it can also display live topology as it changes based on some routing protocol (\dynamic).

[...]

\end{quote}

\vspace{0.5cm}\noindent\textsc{Comment 2}\\
For example the guifi.net management system is able to generate firmware configurations (building of the entire firmware is due to the closed-source policy of Mikrotik, a different issue than for openWRT based systems) from a web-user interface for many different devices. But the paper claims this as a somehow unique feature of the nodewatcher platform. 

\vspace{0.5cm}\noindent\textsc{Response}\\
This fact is now reflected in the survey results table and a paragraph in related work has also been modified, to more explicitly show that the Guifi.net framework does support configuration generation.

\begin{quote}
[...]

While the Guifi.net framework does support generating device configuration, none of the existing solutions support generating functional and pre-configured firmware images that can be directly flashed to devices.

[...]
\end{quote}

\vspace{0.5cm}\noindent\textsc{Comment 3}\\
Another interesting comparison would be on the implications of different designs approaches. One examples is the issue of centrality, single-point of failure, and security which seems pretty neglected in the whole discussion but, to the best of my knowledge, plays a very important role in community networks.

\vspace{0.5cm}\noindent\textsc{Response}\\
We have now added a discussion subsection (Section 4.5 titled \textit{Security, availability and federation}) dealing with the raised concerns.
It now contains the following paragraphs.

\begin{quote}
[...]

Community networks are by their nature decentralized networks which grow in an ad-hoc fashion.
Some community networks may be concerned that having a centralized management system presents a single point of failure for the network, compromise its security or centralize the community too much.
In this section we analyse these concerns and argue that this may not be the case.

In order to support high availability scenarios, standard approaches like using multiple redundant servers and performing database replication, should be considered.
But even in case all redundancy fails, this will not affect the functioning of the actual community network, as operation of the nodes and routing protocols does not in any way rely on there being a \nodewatcher{} server.
Therefore, in the worst case, the only process that will be interrupted is network monitoring and support for managing nodes.

The issue of centralization can be addressed by federation. 
While \nodewatcher{} core does not explicitly support federated deployments, its modular nature enables communities to easily implement it as a module.
Assuming that there are multiple independent subcommunities within one larger community, there are two basic approaches in making \nodewatcher{} federated.

\begin{description}
    \item[Independent installations.] Each independent subcommunity or routing domain would have its own \nodewatcher{} installation which performs registration and monitoring for its own nodes.
    In this way, it would be completely independent from the centralized instance.
    If the community then wants to have an aggregated picture of the whole network, another top-level \nodewatcher{} instance may be deployed which will use pull and/or push from all the other subcommunity \nodewatcher{} installations.
    In this manner, the top-level installation would not support registration of nodes and would not monitor the nodes directly.
    Since in \nodewatcher{} these are all modules, they can be easily removed.
    Instead, the top-level instance would just get the data from subcommunity installations and use it as is.
    Because of the modular design, one would only need to develop a module that knows how to aggregate this data from multiple subcommunities and store it using the existing schema.

    \item[Single installation.] The problem with having multiple installations is that it may be hard to handle merge/split scenarios.
    So instead of having multiple installations, one could also use just a single \nodewatcher{} installation and just structure the nodes and permissions in such a way that each subcommunity has their space.
    This is similar to how the Guifi.net~[17, 24] dashboard splits nodes into zones.
    In this case, the server infrastructure would still be shared, but control would be distributed over multiple communities.
    Since there is no need for all the nodes to see each other (only \nodewatcher{} needs to be able to communicate with them), this is already possible using the current implementation.
    Currently, there is a module that supports \textit{projects}, but these have a completely flat structure.
    A flat structure does not scale to a large number of subcommunities.
    A better way would be to develop a module that would enable nicer visual grouping of nodes, using a parent-child concept similar to the Guifi.net zones.
    As far as topology and map visualizations go, the existing implementation already supports disconnected islands of nodes.
\end{description}

The last concern regards security.
A centralized network management installation might be an attractive target for attackers.
Since \nodewatcher{} holds node configurations, those might contain sensitive information like passwords.
In order to minimize this exposure, public key authentication is supported and should be used instead of passwords whenever possible.
In this case only the public keys are stored by \nodewatcher{} and access to them does not grant access to the nodes themselves.
An additional security concern is for nodes to misreport data of other nodes, which would confuse the monitoring system, so it would display incorrect data.
This is why \nodewatcher{} also supports secure authentication of node data by using public keys mutually verified via the TLS protocol.

[...]

\end{quote}

\vspace{0.5cm}\noindent\textsc{Comment 4}\\
Another critical implication seems that the proposed system mandates exclusive configuration rights as any manual parameter change by a node-admin would violate the foreseen approach. This could also be considered a real burden when trying for example to test different parameters (eg when looking for link channels with least interference and highest TP in a given environment).

\vspace{0.5cm}\noindent\textsc{Response}\\
It is true that the system will actively validate current node configuration with the pre-configured one and emit warnings in case there are mismatches.
But these are only warnings, meant for node maintainers.
The system will therefore not automatically fix any of these problems and maintainers may choose to ignore the warning if they know that it is expected.
Functionality for muting certain warnings by the node maintainers is also planned, so that node maintainers may mark certain warnings as acknowledged so they will not be raised again.
When an optimal configuration is found, it can then be saved into \nodewatcher{}, so it will exist even if the node later malfunctions and needs to be configured again.

\textit{Link and channel planning.} We intend to implement advanced functionality in the future.
Since \nodewatcher{} has access to live wireless survey data from multiple vantage points in an area, this information, combined with elevation data, may be used to assist link planning.

\vspace{0.5cm}\noindent\textsc{Comment 5}\\
It remains unclear to what extend the proposed system can indeed achieve its promises. An overview of successful adoptions by other communities or completely different (unforeseen by the original developers) scenarios would be interesting. The authors could describe in more detail since how long and with which acceptance and experience the new system (nodewatcher v3) has been used in their own community.

\vspace{0.5cm}\noindent\textsc{Response}\\
Some usage scenarios and requirements of other communities simply cannot be predicted. We have based \nodewatcher{} v3 platform on our requirements as well as discussions with maintainers of other community networks. The proposed platform is therefore the first attempt to address all these diverse requirements in a single, modular system. However, only time will tell if the design is really flexible enough and if communities will be willing to use and collaborate on a common platform. From the current experience we can assume that the interest indeed exists as at least two communities have already expressed their interest in using \nodewatcher{} v3 as the foundation for their network. We have therefore highlighted how the \nodewatcher{} v3 platform is being used by other communities by modifying the the following paragraphs in sections 4, 4.1 and 4.4.

\begin{quote}

[...]

Primary management of the network is currently still based on the older version 2.0 of \nodewatcher{}, while the new version presented in this paper is being run in parallel, since the beginning of 2015, in order to enable a smooth transition.
The old version is designed similarly to other existing community network platforms that we surveyed in Section~2 and shares many of the same problems.
Due to this state we have a unique opportunity to qualitatively compare the workings of both solutions and show how the new version of the platform substantially improves network management by addressing the exposed problems.

[...]

It is much easier to support new devices and keep up with the pace of requirements from other communities in the new platform.
Currently, our platform is also being used by the neighbouring community network in Croatia where they use some unique devices due to their cheap local availability.
In old version of the platform, every new device required substantial effort to support it properly as \nodewatcher{} required substantial changes to the provisioning system code.
Additionally, \nodewatcher{} did not have advanced validation capabilities, resulting several times in erroneous configurations which required re-flashing to fix.
In contrast, the new platform enabled us to quickly support the new device, simply by writing a new device descriptor for it (see Section~3.3).

[...]

Additionally, in the beginning of 2015, the \nodewatcher{} platform has been chosen to be the basis for the Commotion Wireless platform~(Josh King. \textit{Announcing collaboration with wlan slovenija}. commotionwireless.net, 2015).
In order to adapt to the specifics of the Commotion network, \nodewatcher{} has been extended to support security features, such as node-server mutual authentication and encryption of monitoring data, and support for data push in addition to data pull.
The platform's modular architecture has shown itself to be particularly suitable for customizing solutions for specific communities.

[...]

\end{quote}

\end{document}
